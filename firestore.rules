/**
 * Core Philosophy: This ruleset enforces a multi-tiered security model tailored for a marketplace and community platform.
 * It combines strict user-ownership for private data, public read access with owner-only writes for shared content,
 * collaborative access for shared resources like chat, and a role-based system for administrative privileges.
 * The default posture is secure, denying access unless explicitly granted.
 *
 * Data Structure: The data is organized into a mix of top-level collections and user-specific subcollections.
 * - Top-level collections like `/products`, `/community_posts`, and `/articles` store public or semi-public data.
 * - User-specific data, such as `/users/{userId}/favorites` and `/users/{userId}/notifications`, is nested under
 *   the user's document, using the path for inherent ownership-based security.
 * - A dedicated `/roles_admin` collection manages administrator privileges, separating role management from user profile data.
 *
 * Key Security Decisions:
 * - Admin Rights: Administrator privileges are determined by the existence of a user's UID as a document ID in the
 *   `/roles_admin` collection. This is more secure than relying on a field in a user's profile.
 * - Authorization Independence: Authorization-critical data (e.g., `farmerId` on a Product, `participantIds` on a
 *   Conversation) is denormalized directly onto the documents being secured. This eliminates slow and costly `get()`
 *   calls in most rules, making them faster and more reliable.
 * - User Privacy: Listing all users from the `/users` collection is strictly forbidden to protect user privacy.
 * - Shared Access: Collections like `/conversations` and `/calls` grant access based on a list of participant UIDs
 *   stored within the document itself.
 * - Destructive Operations: All `update` and `delete` operations are protected by a check to ensure the document
 *   exists (`resource != null`) before allowing the operation, preventing unintended side effects.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------
    // Helper Functions
    // --------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user is the owner of a resource,
     * based on a provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the authenticated user is the owner of an EXISTING resource.
     * Crucial for safe update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Checks if the authenticated user has admin privileges by looking for
     * their UID in the dedicated admin roles collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Validates that the user creating a document inside their own data tree
     * is correctly setting the back-reference `userId` field.
     */
    function isCreatingOwnData(userId) {
      return isOwner(userId) && request.resource.data.userId == userId;
    }

    /**
     * Enforces that the `userId` field on a document inside a user's data tree
     * cannot be changed after creation.
     */
    function isNotMovingData() {
      return request.resource.data.userId == resource.data.userId;
    }

    /**
     * Checks if the current user is a participant in a conversation.
     * This requires reading the parent conversation document.
     * Note: This `get()` call is necessary to secure list operations on the subcollection.
     */
    function isConversationParticipant(conversationId) {
      let conversation = get(/databases/$(database)/documents/conversations/$(conversationId));
      return isSignedIn() && request.auth.uid in conversation.data.participantIds;
    }

    // --------------------------------
    // Collection Rules
    // --------------------------------

    /**
     * @description Manages user profiles. Users can create, read, and update their own profile. Listing all users is forbidden.
     * @path /users/{userId}
     * @allow (create) An authenticated user creating their own profile document: `users/user_abc`.
     * @deny (get) A user trying to read another user's profile: `users/user_xyz`.
     * @deny (list) Any user trying to list all documents in the `/users` collection.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Manages admin role lookups. Read-only for admins to see other admins. No client can write to this collection.
     * @path /roles_admin/{adminId}
     * @allow (get) An admin reading an admin role document.
     * @deny (create) Any client attempting to create a new admin role.
     * @principle Secures critical role management by making it read-only from the client.
     */
    match /roles_admin/{adminId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Stores product listings. Anyone can read products, but only the farmer who created it can modify or delete it.
     * @path /products/{productId}
     * @allow (create) A signed-in user (farmer) creating a product with their own `farmerId`.
     * @deny (update) A user trying to update a product where `resource.data.farmerId` does not match their UID.
     * @principle Public read with owner-only writes.
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.farmerId == request.auth.uid;
      allow update: if isOwner(resource.data.farmerId) && resource != null;
      allow delete: if isOwner(resource.data.farmerId) && resource != null;
    }

    /**
     * @description Records calls between consumers and farmers. Only participants of the call can read or create records.
     * @path /calls/{callId}
     * @allow (get) The consumer or farmer involved in the call reading the record.
     * @deny (get) A third-party user trying to read a call record they were not part of.
     * @principle Secures access to a closed set of collaborators (the two call participants).
     */
    match /calls/{callId} {
      allow get: if isSignedIn() && (request.auth.uid == resource.data.consumerId || request.auth.uid == resource.data.farmerId);
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.consumerId == request.auth.uid;
      allow update: if isSignedIn() && (request.auth.uid == resource.data.consumerId || request.auth.uid == resource.data.farmerId) && resource != null;
      allow delete: if isSignedIn() && (request.auth.uid == resource.data.consumerId || request.auth.uid == resource.data.farmerId) && resource != null;
    }

    /**
     * @description Contains reviews of farmers. Anyone can read reviews, but only the author can manage their own review.
     * @path /reviews/{reviewId}
     * @allow (create) A signed-in consumer creating a review with their own `consumerId`.
     * @deny (delete) A user trying to delete a review written by someone else.
     * @principle Public read with owner-only writes.
     */
    match /reviews/{reviewId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.consumerId == request.auth.uid;
      allow update: if isOwner(resource.data.consumerId) && resource != null;
      allow delete: if isOwner(resource.data.consumerId) && resource != null;
    }

    /**
     * @description Stores a user's private list of favorite items. Access is restricted to the user who owns the list.
     * @path /users/{userId}/favorites/{favoriteId}
     * @allow (list) A user listing their own favorites at `/users/user_abc/favorites`.
     * @deny (get) A user trying to read a favorite from another user's list at `/users/user_xyz/favorites/fav_123`.
     * @principle Enforces strict ownership based on the document path.
     */
    match /users/{userId}/favorites/{favoriteId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isCreatingOwnData(userId);
      allow update: if isExistingOwner(userId) && isNotMovingData();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Stores a user's private notifications. Access is restricted to the user who owns them.
     * @path /users/{userId}/notifications/{notificationId}
     * @allow (list) A user listing their own notifications at `/users/user_abc/notifications`.
     * @deny (update) A user trying to mark a notification as read for another user.
     * @principle Enforces strict ownership based on the document path.
     */
    match /users/{userId}/notifications/{notificationId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isCreatingOwnData(userId);
      allow update: if isExistingOwner(userId) && isNotMovingData();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Contains informational articles. Publicly readable, but only admins can create or modify them.
     * @path /articles/{articleId}
     * @allow (list) Any user or visitor listing all articles.
     * @deny (create) A non-admin user trying to publish an article.
     * @principle Public read with role-based writes (Admins only).
     */
    match /articles/{articleId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Stores posts for the community feed. Anyone can read, but only authors can manage their own posts.
     * @path /community_posts/{postId}
     * @allow (create) A signed-in user creating a post with their own `authorId`.
     * @deny (delete) A user trying to delete a post they did not write.
     * @principle Public read with owner-only writes.
     */
    match /community_posts/{postId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isOwner(resource.data.authorId) && resource != null;
      allow delete: if isOwner(resource.data.authorId) && resource != null;

      /**
       * @description Stores comments on community posts. Publicly readable, owner-only writes.
       * @path /community_posts/{postId}/comments/{commentId}
       * @allow (create) A signed-in user creating a comment with their own `authorId`.
       * @deny (update) A user trying to edit someone else's comment.
       * @principle Public read with owner-only writes.
       */
      match /comments/{commentId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
        allow update: if isOwner(resource.data.authorId) && resource != null;
        allow delete: if isOwner(resource.data.authorId) && resource != null;
      }
    }

    /**
     * @description Manages chat conversations. Only users listed in `participantIds` can access the conversation.
     * @path /conversations/{conversationId}
     * @allow (get) A user who is a participant reading the conversation document.
     * @deny (get) A user trying to read a conversation they are not a part of.
     * @principle Secures access to a closed set of collaborators.
     */
    match /conversations/{conversationId} {
      allow get: if isSignedIn() && request.auth.uid in resource.data.participantIds;
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.auth.uid in request.resource.data.participantIds;
      allow update: if isSignedIn() && request.auth.uid in resource.data.participantIds && resource != null;
      allow delete: if false; // Deleting conversations is a sensitive action, disable on client.
    }

    /**
     * @description Stores messages within a conversation. Access is inherited from the parent conversation's participants.
     * @path /conversations/{conversationId}/messages/{messageId}
     * @allow (list) A participant of the conversation listing messages.
     * @deny (get) A non-participant trying to read a message.
     * @principle Secures subcollection access by checking permissions on the parent document.
     */
    match /conversations/{conversationId}/messages/{messageId} {
      allow get: if isConversationParticipant(conversationId);
      allow list: if isConversationParticipant(conversationId);
      allow create: if isConversationParticipant(conversationId) && request.resource.data.senderId == request.auth.uid;
      allow update: if isOwner(resource.data.senderId) && resource != null && isConversationParticipant(conversationId);
      allow delete: if isOwner(resource.data.senderId) && resource != null && isConversationParticipant(conversationId);
    }

    /**
     * @description Stores user-submitted support tickets. Access is limited to the reporter and admins.
     * @path /support_tickets/{ticketId}
     * @allow (get) The user who created the ticket or an admin reading the ticket.
     * @deny (get) A user trying to read another user's support ticket.
     * @principle Secures access to the document owner and users with a specific role (admin).
     */
    match /support_tickets/{ticketId} {
      allow get: if isOwner(resource.data.reporterId) || isAdmin();
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.reporterId == request.auth.uid;
      allow update: if (isOwner(resource.data.reporterId) || isAdmin()) && resource != null;
      allow delete: if isAdmin() && resource != null;
    }
  }
}